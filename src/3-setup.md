# الإعداد

نظرًا لأن الهدف النهائي لهذا المشروع هو الحصول على مُحاكي يمكن بناؤه لكل من سطح المكتب ومتصفح الويب، سنقوم ببناء هذا المشروع بشكل غير معتاد قليلاً. بين الإصدارين، يجب أن يكون المحاكي الفعلي لنظام Chip-8 متماثلًا تمامًا، فقط أشياء مثل قراءة الملف وعرض الشاشة ستكون مختلفة بين سطح المكتب والمتصفح. لهذا الغرض، سنقوم بإنشاء الواجهة الخلفية، والتي سأسميها *النواة*، كوحدة مستقلة يمكن استخدامها من قبل واجهاتنا المستقبلية.

انتقل إلى المجلد حيث ستخزن مشروعك وقم بتنفيذ الأمر التالي. لا تقم بتضمين رمز `$`، فهو ببساطة للإشارة إلى أن هذا أمر في الطرفية.

```
$ cargo init chip8_core --lib
```

علم `--lib` يخبر `cargo` بإنشاء مكتبة بدلاً من وحدة تنفيذية. هذا هو المكان الذي سيتم فيه وضع واجهة المحاكي الخلفية. لقد أسميتها `chip8_core` لأغراض هذا المشروع، ولكنك حر في تسميتها كما تشاء.

أما بالنسبة للواجهة الأمامية، سنقوم بإنشاء وحدة إضافية لحفظ هذا الكود:

```
$ cargo init desktop
```

على عكس النواة، فإن هذا ينشئ مشروعًا تنفيذيًا فعليًا. إذا قمت بذلك بشكل صحيح، يجب أن يبدو هيكل المجلدات الخاص بك الآن كما يلي:

![هيكل الملفات الأولي](img/init_tree.png)

كل ما تبقى هو إخبار واجهة `desktop` الأمامية عن مكان العثور على `chip8_core`. افتح ملف `desktop/Cargo.toml` وأضف السطر التالي تحت `[dependencies]`:

```toml
chip8_core = { path = "../chip8_core" }
```

نظرًا لأن `chip8_core` فارغة حاليًا، فإن هذا لا يضيف أي شيء فعليًا، ولكنه شيء سيحتاج إلى القيام به في النهاية. حاول تجميع وتشغيل المشروع، فقط للتأكد من أن كل شيء يعمل. من داخل مجلد `desktop`، قم بتنفيذ:

```
$ cargo run
```

إذا تم الإعداد بشكل صحيح، يجب أن يظهر "Hello, world!". رائع! بعد ذلك، سنبدأ في محاكاة وحدة المعالجة المركزية وبدء إنشاء شيء أكثر إثارة للاهتمام.

## تعريف المحاكي

الجزء الأساسي من النظام هو وحدة المعالجة المركزية، لذا سنبدأ من هناك عند إنشاء المحاكي. في الوقت الحالي، سنقوم بتطوير واجهة `chip8_core` الخلفية بشكل أساسي، ثم نعود لتوفير واجهتنا الأمامية عندما نكون قد تقدمنا بشكل جيد. سنبدأ بالعمل في ملف `chip8_core/src/lib.rs` (يمكنك حذف كود الاختبار الذي تم إنشاؤه تلقائيًا). قبل أن نضيف أي وظائف، دعنا نسترجع بعض المفاهيم حول ما نحن على وشك القيام به.

المحاكاة هي ببساطة تنفيذ برنامج تم كتابته أصلاً لنظام مختلف، لذا فهي تعمل بشكل مشابه جدًا لتنفيذ برنامج كمبيوتر حديث. عند تشغيل أي برنامج قديم، يتم قراءة سطر من الكود، ويتم فهمه من قبل الكمبيوتر لأداء مهمة ما مثل تعديل متغير، أو إجراء مقارنة، أو القفز إلى سطر مختلف من الكود؛ ثم يتم تنفيذ هذا الإجراء، وينتقل التنفيذ إلى السطر التالي لتكرار هذه العملية. إذا كنت قد درست المترجمات، فستعرف أنه عند تشغيل النظام للكود، فإنه لا يقوم بذلك سطرًا بسطر، بل يحول الكود إلى تعليمات يفهمها المعالج، ثم يقوم بتنفيذ هذه الحلقة على تلك التعليمات. هذا بالضبط كيف سيعمل المحاكي الخاص بنا. سنقوم باجتياز القيم واحدة تلو الأخرى في برنامج اللعبة، __جلب__ التعليمات المخزنة هناك، __فك تشفير__ العملية التي يجب القيام بها، ثم __تنفيذها__، قبل الانتقال إلى التالي. هذه الحلقة *الجلب-فك التشفير-التنفيذ* ستشكل جوهر محاكاة وحدة المعالجة المركزية.

مع أخذ ذلك في الاعتبار، لنبدأ بتعريف فئة ستقوم بإدارة المحاكي الخاص بنا. في `lib.rs`، سنضيف بنية جديدة فارغة:

```rust
pub struct Emu {
}
```

هذه البنية ستكون الكائن الرئيسي لواجهة المحاكي الخلفية، وبالتالي يجب أن تتعامل مع تشغيل اللعبة الفعلية، وأن تكون قادرة على تمرير المعلومات المطلوبة ذهابًا وإيابًا من الواجهة الأمامية (مثل ما هو موجود على الشاشة وضغطات الأزرار).

## عداد البرنامج

ولكن ماذا نضع في كائن `Emu` الخاص بنا؟ كما ناقشنا سابقًا، يحتاج البرنامج إلى معرفة مكان التنفيذ الحالي في اللعبة. تقوم جميع وحدات المعالجة المركزية بتحقيق ذلك عن طريق الاحتفاظ بفهرس للتعليمة الحالية، مخزنة في *سجل* خاص يعرف باسم *عداد البرنامج*، أو PC اختصارًا. سيكون هذا مفتاحًا لجزء *الجلب* من الحلقة، وسيزداد خلال اللعبة أثناء تشغيلها، ويمكن حتى تعديله يدويًا بواسطة بعض التعليمات (لأشياء مثل القفز إلى قسم مختلف من الكود أو استدعاء subroutine). دعنا نضيف هذا إلى البنية:

```rust
pub struct Emu {
    pc: u16,
}
```

## الذاكرة العشوائية (RAM)

بينما يمكننا القراءة من ملف اللعبة في كل مرة نحتاج فيها إلى تعليمة جديدة، إلا أن هذا بطيء جدًا وغير فعال، وببساطة ليس كيف تعمل الأنظمة الحقيقية. بدلاً من ذلك، تم تصميم Chip-8 لنسخ برنامج اللعبة بالكامل في مساحة الذاكرة العشوائية الخاصة به، حيث يمكن بعد ذلك القراءة منه والكتابة إليه حسب الحاجة. تجدر الإشارة إلى أن العديد من الأنظمة، مثل Game Boy، لا تسمح لوحدة المعالجة المركزية بالكتابة فوق مناطق الذاكرة التي يتم تخزين اللعبة فيها (لن ترغب في أن يتسبب خطأ في إفساد كود اللعبة بالكامل). ومع ذلك، فإن Chip-8 لا يحتوي على مثل هذا القيد. نظرًا لأن Chip-8 لم يكن نظامًا ماديًا أبدًا، فلا يوجد معيار رسمي لكمية الذاكرة التي يجب أن يحتويها. ومع ذلك، فقد تم تصميمه في الأصل ليتم تنفيذه على أجهزة كمبيوتر تحتوي على 4096 بايت (4 كيلوبايت) من الذاكرة العشوائية، لذا هذا ما سنمنحه أيضًا. لن تستخدم معظم البرامج كل هذه الذاكرة، لكنها موجودة إذا احتاجت إليها. دعنا نحدد ذلك في برنامجنا.

```rust
const RAM_SIZE: usize = 4096;

pub struct Emu {
    pc: u16,
    ram: [u8; RAM_SIZE],
}

```

## الشاشة

يستخدم Chip-8 شاشة أحادية اللون بدقة 64x32 (1 بت لكل بكسل). لا يوجد شيء خاص جدًا في هذا، ومع ذلك فهو أحد الأشياء القليلة في واجهتنا الخلفية التي يجب أن تكون قابلة للوصول من قبل واجهاتنا الأمامية المختلفة، وللمستخدم. على عكس العديد من الأنظمة، لا يقوم Chip-8 بمسح شاشته تلقائيًا لإعادة الرسم في كل إطار، بدلاً من ذلك يتم الحفاظ على حالة الشاشة، ويتم رسم الرسومات الجديدة عليها (هناك أمر لمسح الشاشة). يمكننا الاحتفاظ ببيانات الشاشة هذه في مصفوفة في كائن Emu الخاص بنا. يعتبر Chip-8 أيضًا أكثر أساسية من معظم الأنظمة حيث أننا نتعامل فقط مع لونين - الأسود والأبيض. نظرًا لأن هذه شاشة 1 بت، يمكننا ببساطة تخزين مصفوفة من القيم المنطقية كما يلي:

```rust
pub const SCREEN_WIDTH: usize = 64;
pub const SCREEN_HEIGHT: usize = 32;

const RAM_SIZE: usize = 4096;

pub struct Emu {
    pc: u16,
    ram: [u8; RAM_SIZE],
    screen: [bool; SCREEN_WIDTH * SCREEN_HEIGHT],
}

```

ستلاحظ أيضًا أنه على عكس الثابت السابق، قمنا بتعريف أبعاد الشاشة كثوابت عامة. هذه واحدة من القطع القليلة من المعلومات التي ستكون الواجهة الأمامية بحاجة إليها لرسم الشاشة فعليًا.

## سجلات V

بينما يحتوي النظام على قدر كبير من الذاكرة العشوائية للعمل بها، يعتبر الوصول إلى الذاكرة العشوائية بطيئًا نسبيًا (ولكنه لا يزال أسرع بكثير من القراءة من القرص). لتسريع الأمور، يعرّف Chip-8 ستة عشر سجلًا من 8 بت يمكن للعبة استخدامها كما تشاء لعمليات أسرع. يُشار إلى هذه السجلات باسم *سجلات V*، وعادة ما يتم ترقيمها بالنظام الست عشري من V0 إلى VF (لست متأكدًا تمامًا مما يعنيه الحرف *V*)، وسنقوم بتجميعها معًا في مصفوفة واحدة في بنية Emu الخاصة بنا.

```rust
pub const SCREEN_WIDTH: usize = 64;
pub const SCREEN_HEIGHT: usize = 32;

const RAM_SIZE: usize = 4096;
const NUM_REGS: usize = 16;

pub struct Emu {
    pc: u16,
    ram: [u8; RAM_SIZE],
    screen: [bool; SCREEN_WIDTH * SCREEN_HEIGHT],
    v_reg: [u8; NUM_REGS],
}

```

## سجل I

هناك أيضًا سجل آخر من 16 بت يعرف باسم *سجل I*، والذي يستخدم للفهرسة في الذاكرة العشوائية للقراءة والكتابة. سنتعمق في التفاصيل الدقيقة لكيفية عمل هذا لاحقًا، ولكن في الوقت الحالي نحتاج فقط إلى وجوده.

```rust
pub const SCREEN_WIDTH: usize = 64;
pub const SCREEN_HEIGHT: usize = 32;

const RAM_SIZE: usize = 4096;
const NUM_REGS: usize = 16;

pub struct Emu {
    pc: u16,
    ram: [u8; RAM_SIZE],
    screen: [bool; SCREEN_WIDTH * SCREEN_HEIGHT],
    v_reg: [u8; NUM_REGS],
    i_reg: u16,
}

```

## المكدس

تحتوي وحدة المعالجة المركزية أيضًا على *مكدس* صغير، وهو عبارة عن مصفوفة من القيم ذات 16 بت يمكن لوحدة المعالجة المركزية القراءة منها والكتابة إليها. يختلف المكدس عن الذاكرة العشوائية العادية حيث يمكن فقط القراءة/الكتابة من/إلى المكدس عبر مبدأ "آخر داخل، أول خارج (LIFO)" (مثل كومة من الفطائر!)، عندما تذهب لالتقاط (إخراج) قيمة، فإنك تزيل آخر قيمة قمت بإضافتها (إدخالها). على عكس العديد من الأنظمة، لا يُستخدم المكدس لأغراض عامة. الأوقات الوحيدة المسموح فيها باستخدام المكدس هي عند الدخول أو الخروج من subroutine، حيث يتم استخدام المكدس لمعرفة المكان الذي بدأت منه حتى تتمكن من العودة بعد انتهاء الروتين. مرة أخرى، لا يحدد Chip-8 رسميًا عدد الأرقام التي يمكن أن يحتفظ بها المكدس، ولكن 16 هو رقم شائع لمطوري المحاكاة. هناك عدد من الطرق المختلفة التي يمكننا من خلالها تنفيذ المكدس الخاص بنا، ربما تكون أسهل طريقة هي استخدام الكائن `std::collections::VecDeque` من مكتبة Rust القياسية. يعمل هذا بشكل جيد لبناء سطح المكتب فقط، ولكن في وقت كتابة هذا المقال، لا تعمل العديد من العناصر في مكتبة `std` مع إصدارات WebAssembly. بدلاً من ذلك، سنقوم بذلك بالطريقة القديمة، باستخدام مصفوفة ذات حجم ثابت وفهرس حتى نعرف مكان الجزء العلوي من المكدس، والمعروف باسم *مؤشر المكدس* (SP).

```rust
pub const SCREEN_WIDTH: usize = 64;
pub const SCREEN_HEIGHT: usize = 32;

const RAM_SIZE: usize = 4096;
const NUM_REGS: usize = 16;
const STACK_SIZE: usize = 16;

pub struct Emu {
    pc: u16,
    ram: [u8; RAM_SIZE],
    screen: [bool; SCREEN_WIDTH * SCREEN_HEIGHT],
    v_reg: [u8; NUM_REGS],
    i_reg: u16,
    sp: u16,
    stack: [u16; STACK_SIZE],
}

```

## الأزرار

يدعم Chip-8 عددًا كبيرًا بشكل مدهش من الأزرار يصل إلى 16 زرًا، وعادة ما يتم ترقيمها بالنظام الست عشري من 0 إلى 9، ومن A إلى F. يتم ترتيب الأزرار بشكل مشابه لتخطيط الهاتف، مع وضع A و B على جانبي 0، و C إلى F على العمود الأيمن، مما يشكل شبكة 4x4.

![تخطيط لوحة المفاتيح إلى أزرار Chip-8](img/input_layout.png)

نحتاج إلى تتبع الأزرار التي يتم الضغط عليها، وبالتالي يمكننا استخدام مصفوفة من القيم المنطقية لتتبع الحالات.

```rust
pub const SCREEN_WIDTH: usize = 64;
pub const SCREEN_HEIGHT: usize = 32;

const RAM_SIZE: usize = 4096;
const NUM_REGS: usize = 16;
const STACK_SIZE: usize = 16;
const NUM_KEYS: usize = 16;

pub struct Emu {
    pc: u16,
    ram: [u8; RAM_SIZE],
    screen: [bool; SCREEN_WIDTH * SCREEN_HEIGHT],
    v_reg: [u8; NUM_REGS],
    i_reg: u16,
    sp: u16,
    stack: [u16; STACK_SIZE],
    keys: [bool; NUM_KEYS],
}

```

## المؤقتات

لقد كان هذا كثيرًا للتعامل معه دفعة واحدة، ولكننا الآن في العناصر النهائية. يحتوي Chip-8 أيضًا على سجلين خاصين آخرين يستخدمهما كمؤقتات. الأول، *مؤقت التأخير*، يستخدمه النظام كمؤقت عادي، حيث يقوم بالعد التنازلي في كل دورة ويقوم ببعض الإجراءات إذا وصل إلى 0. أما *مؤقت الصوت*، فيقوم أيضًا بالعد التنازلي في كل دورة ساعة، ولكن عند الوصول إلى 0 يصدر صوتًا. تعيين *مؤقت الصوت* إلى 0 هو الطريقة الوحيدة لإصدار الصوت على Chip-8، كما سنرى لاحقًا. كلاهما عبارة عن سجلات 8 بت، ويجب دعمهما حتى نتمكن من المتابعة.

```rust
pub const SCREEN_WIDTH: usize = 64;
pub const SCREEN_HEIGHT: usize = 32;

const RAM_SIZE: usize = 4096;
const NUM_REGS: usize = 16;
const STACK_SIZE: usize = 16;
const NUM_KEYS: usize = 16;

pub struct Emu {
    pc: u16,
    ram: [u8; RAM_SIZE],
    screen: [bool; SCREEN_WIDTH * SCREEN_HEIGHT],
    v_reg: [u8; NUM_REGS],
    i_reg: u16,
    sp: u16,
    stack: [u16; STACK_SIZE],
    keys: [bool; NUM_KEYS],
    dt: u8,
    st: u8,
}
```

## التهيئة

هذا يكفي في الوقت الحالي، دعنا ننفذ مُنشئ `new` لهذه الفئة قبل أن ننتقل إلى الجزء التالي. بعد تعريف `struct`، سنقوم بتنفيذ وتعيين القيم الافتراضية:

```rust
// -- الكود غير المتغير تم حذفه --

const START_ADDR: u16 = 0x200;

// -- الكود غير المتغير تم حذفه --

impl Emu {
    pub fn new() -> Self {
        Self {
            pc: START_ADDR,
            ram: [0; RAM_SIZE],
            screen: [false; SCREEN_WIDTH * SCREEN_HEIGHT],
            v_reg: [0; NUM_REGS],
            i_reg: 0,
            sp: 0,
            stack: [0; STACK_SIZE],
            keys: [false; NUM_KEYS],
            dt: 0,
            st: 0,
        }
    }
}
```

يبدو كل شيء واضحًا إلى حد ما، نقوم ببساطة بتهيئة جميع القيم والمصفوفات إلى الصفر... باستثناء عداد البرنامج (Program Counter)، الذي يتم تعيينه إلى 0x200 (أي 512 بالنظام العشري). لقد ذكرت السبب وراء ذلك في الفصل السابق، ولكن يجب على المحاكي أن يعرف مكان بداية البرنامج، ومن المعيار في نظام Chip-8 أن يتم تحميل بداية جميع برامج Chip-8 من عنوان الذاكرة 0x200. هذا الرقم سيظهر مرة أخرى، لذا قمنا بتعريفه كقيمة ثابتة.

بهذا نكون قد انتهينا من هذا الجزء! مع وضع الأساس لمحاكاتنا، يمكننا البدء في تنفيذ عملية التنفيذ!

\newpage
