# تنفيذ طرق المحاكاة

لقد أنشأنا الآن بنية `Emu` وحددنا عددًا من المتغيرات لها لإدارتها، بالإضافة إلى تحديد وظيفة التهيئة. قبل أن ننتقل، هناك بعض الطرق المفيدة التي يجب أن نضيفها إلى كائننا الآن والتي ستكون مفيدة بمجرد أن نبدأ في تنفيذ التعليمات.

## Push و Pop

لقد أضفنا كلًا من مصفوفة `stack` ومؤشر `sp` لإدارة مكدس وحدة المعالجة المركزية، ومع ذلك سيكون من المفيد تنفيذ كل من وظيفتي `push` و `pop` حتى نتمكن من الوصول إليها بسهولة.

```rust
impl Emu {
    // -- كود غير متغير محذوف --

    fn push(&mut self, val: u16) {
        self.stack[self.sp as usize] = val;
        self.sp += 1;
    }

    fn pop(&mut self) -> u16 {
        self.sp -= 1;
        self.stack[self.sp as usize]
    }

    // -- كود غير متغير محذوف --
}
```

هذه الوظائف واضحة جدًا. `push` تضيف القيمة المعطاة التي تبلغ 16 بت إلى المكان الذي يشير إليه مؤشر المكدس، ثم تحرك المؤشر إلى الموضع التالي. `pop` تنفذ هذه العملية بشكل عكسي، حيث تحرك مؤشر المكدس إلى القيمة السابقة ثم تعيد ما يوجد هناك. لاحظ أن محاولة إجراء `pop` على مكدس فارغ يؤدي إلى حدوث خطأ تحت التدفق (underflow panic)[^1]. يمكنك إضافة معالجة إضافية هنا إذا أردت، ولكن في حالة حدوث ذلك، فإن ذلك يشير إلى وجود خلل في المحاكي أو كود اللعبة، لذلك أعتقد أن حدوث خطأ كامل مقبول.

## خطوط الرموز (Font Sprites)

لم نتعمق بعد في كيفية عمل شاشة عرض Chip-8، ولكن الفكرة الأساسية الآن هي أنها تعرض *الرموز* (sprites) التي يتم تخزينها في الذاكرة على الشاشة، سطرًا واحدًا في كل مرة. يقع على عاتق مطور اللعبة تحميل الرموز بشكل صحيح قبل نسخها إلى الشاشة. ولكن ألن يكون من الجميل إذا كان النظام يحتوي تلقائيًا على رموز للأشياء الشائعة الاستخدام، مثل الأرقام؟ لقد ذكرت سابقًا أن عداد البرنامج (PC) سيبدأ من العنوان 0x200، تاركًا أول 512 بايت فارغة عن قصد. تستخدم معظم المحاكيات الحديثة هذا المساحة لتخزين بيانات الرموز لأحرف الخط الخاصة بجميع الأرقام السداسية عشرية، أي الأحرف من 0-9 و A-F. يمكننا تخزين هذه البيانات في أي موقع ثابت في الذاكرة العشوائية (RAM)، ولكن هذه المساحة محددة بالفعل على أنها فارغة على أي حال. يتكون كل حرف من خمسة صفوف من ثمانية وحدات بكسل، ويستخدم كل صف بايت واحد من البيانات، مما يعني أن كل حرف يستغرق خمسة بايتات من البيانات بشكل كامل. يوضح الرسم التالي كيفية تخزين الحرف كبايتات.

[^1] *التدفق تحت الصفر* (Underflow) هو عندما تتحول قيمة متغير غير موقعة من فوق الصفر إلى تحت الصفر. في بعض اللغات، قد "تدور" القيمة إلى أعلى قيمة ممكنة، ولكن في Rust يؤدي هذا إلى حدوث خطأ في وقت التشغيل ويجب التعامل معه بشكل مختلف إذا كان مطلوبًا. الأمر نفسه ينطبق على القيم التي تتجاوز القيمة القصوى الممكنة، والمعروفة باسم *التدفق فوق الصفر* (overflow).

\newpage

![رموز خط Chip-8](img/font_diagram.png)

على اليمين، يتم ترميز كل صف في شكل ثنائي. يتم تعيين كل بكسل إلى بت، والذي يتوافق مع ما إذا كان هذا البكسل سيكون أبيض أو أسود. *كل* الرموز في Chip-8 بعرض ثمانية وحدات بكسل، مما يعني أن صف البكسل يتطلب 8 بت (1 بايت). يوضح الرسم أعلاه تخطيط رمز الحرف "1". لا تحتاج الرموز إلى جميع وحدات البت الثمانية من العرض، لذا فإن جميعها تحتوي على نصف أيمن أسود. تم إنشاء رموز لجميع الأرقام السداسية عشرية، ويجب أن تكون موجودة في مكان ما في الذاكرة العشوائية لكي تعمل بعض الألعاب. لاحقًا في هذا الدليل سنغطي التعليمات التي تتعامل مع هذه الرموز، والتي ستوضح كيفية تحميلها وكيف يعرف المحاكي مكان العثور عليها. في الوقت الحالي، نحتاج ببساطة إلى تعريفها. سنفعل ذلك باستخدام مصفوفة ثابتة من البايتات؛ في أعلى ملف `lib.rs`، أضف:

```rust
const FONTSET_SIZE: usize = 80;

const FONTSET: [u8; FONTSET_SIZE] = [
    0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
    0x20, 0x60, 0x20, 0x20, 0x70, // 1
    0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
    0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
    0x90, 0x90, 0xF0, 0x10, 0x10, // 4
    0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
    0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
    0xF0, 0x10, 0x20, 0x40, 0x40, // 7
    0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
    0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
    0xF0, 0x90, 0xF0, 0x90, 0x90, // A
    0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
    0xF0, 0x80, 0x80, 0x80, 0xF0, // C
    0xE0, 0x90, 0x90, 0x90, 0xE0, // D
    0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
    0xF0, 0x80, 0xF0, 0x80, 0x80  // F
];
```

يمكنك رؤية البايتات الموضحة في الرسم البياني للحرف "1" أعلاه، وجميع الأحرف الأخرى تعمل بطريقة مماثلة. الآن بعد أن تم تحديد هذه البايتات، نحتاج إلى تحميلها في الذاكرة العشوائية. قم بتعديل `Emu::new()` لنسخ هذه القيم:

```rust
pub fn new() -> Self {
    let mut new_emu = Self {
        pc: START_ADDR,
        ram: [0; RAM_SIZE],
        screen: [false; SCREEN_WIDTH * SCREEN_HEIGHT],
        v_reg: [0; NUM_REGS],
        i_reg: 0,
        sp: 0,
        stack: [0; STACK_SIZE],
        keys: [false; NUM_KEYS],
        dt: 0,
        st: 0,
    };

    new_emu.ram[..FONTSET_SIZE].copy_from_slice(&FONTSET);

    new_emu
}
```

يقوم هذا بتهيئة كائن `Emu` بنفس الطريقة كما كان من قبل، ولكن ينسخ بيانات رموز الأحرف إلى الذاكرة العشوائية قبل إرجاعه.

سيكون من المفيد أيضًا أن نتمكن من إعادة تعيين المحاكي دون الحاجة إلى إنشاء كائن جديد. هناك طرق أكثر تطورًا للقيام بذلك، ولكننا سنبقيها بسيطة وننشئ وظيفة تعيد تعيين متغيرات العضو إلى قيمها الأصلية عند استدعائها.

```rust
pub fn reset(&mut self) {
    self.pc = START_ADDR;
    self.ram = [0; RAM_SIZE];
    self.screen = [false; SCREEN_WIDTH * SCREEN_HEIGHT];
    self.v_reg = [0; NUM_REGS];
    self.i_reg = 0;
    self.sp = 0;
    self.stack = [0; STACK_SIZE];
    self.keys = [false; NUM_KEYS];
    self.dt = 0;
    self.st = 0;
    self.ram[..FONTSET_SIZE].copy_from_slice(&FONTSET);
}
```

## Tick

مع اكتمال إنشاء كائن `Emu` (في الوقت الحالي)، يمكننا البدء في تحديد كيفية معالجة وحدة المعالجة المركزية لكل تعليمة والتحرك خلال اللعبة. لتلخيص ما تم وصفه في الأجزاء السابقة، ستكون الحلقة الأساسية كما يلي:

1. جلب القيمة من لعبتنا (التي تم تحميلها في الذاكرة العشوائية) من عنوان الذاكرة المخزن في عداد البرنامج (Program Counter).
2. فك تشفير هذه التعليمات.
3. التنفيذ، والذي قد يتضمن تعديل سجلات وحدة المعالجة المركزية أو الذاكرة العشوائية.
4. تحريك عداد البرنامج إلى التعليمات التالية وتكرار العملية.

لنبدأ بإضافة معالجة الأوامر إلى وظيفة `tick`، بدءًا من خطوة الجلب:

```rust
// -- كود غير متغير محذوف --

pub fn tick(&mut self) {
    // الجلب
    let op = self.fetch();
    // فك التشفير
    // التنفيذ
}

fn fetch(&mut self) -> u16 {
    // TODO
}

```

سيتم استدعاء وظيفة `fetch` داخليًا فقط كجزء من حلقة `tick`، لذا لا تحتاج إلى أن تكون عامة. الغرض من هذه الوظيفة هو الحصول على التعليمات التي نحن على وشك تنفيذها (المعروفة باسم *opcode*) لاستخدامها في الخطوات التالية من هذه الدورة. إذا لم تكن على دراية بتنسيق تعليمات Chip-8، أوصي بمراجعة [الملخص](#eb) من الفصول السابقة.

لحسن الحظ، فإن Chip-8 أسهل من العديد من الأنظمة. أولاً، هناك فقط 35 opcode للتعامل معها مقارنة بالمئات التي تدعمها العديد من المعالجات. بالإضافة إلى ذلك، تقوم العديد من الأنظمة بتخزين معلمات إضافية لكل opcode في البايتات اللاحقة (مثل المعاملات للإضافة)، بينما يقوم Chip-8 بترميز هذه المعلمات في الـ opcode نفسه. بسبب هذا، فإن جميع opcodes في Chip-8 هي بالضبط 2 بايت، وهو أكبر من بعض الأنظمة الأخرى، ولكن التعليمات بأكملها مخزنة في هذين البايتين، بينما قد تستهلك الأنظمة الأخرى المعاصرة ما بين 1 إلى 3 بايتات لكل دورة.

يتم ترميز كل opcode بشكل مختلف، ولكن لحسن الحظ نظرًا لأن جميع التعليمات تستهلك بايتين، فإن عملية الجلب هي نفسها لجميعها، ويتم تنفيذها على النحو التالي:

```rust
fn fetch(&mut self) -> u16 {
    let higher_byte = self.ram[self.pc as usize] as u16;
    let lower_byte = self.ram[(self.pc + 1) as usize] as u16;
    let op = (higher_byte << 8) | lower_byte;
    self.pc += 2;
    op
}
```

تقوم هذه الوظيفة بجلب الـ opcode الذي يبلغ 16 بت المخزن في عداد البرنامج الحالي. نقوم بتخزين القيم في الذاكرة العشوائية كقيم 8 بت، لذا نقوم بجلب اثنين ودمجهما كـ Big Endian. ثم يتم زيادة عداد البرنامج بمقدار البايتين اللذين قرأناهما للتو، ويتم إرجاع الـ opcode الذي تم جلبه لمزيد من المعالجة.

## Timer Tick

تذكر مواصفات Chip-8 أيضًا وجود مؤقتين خاصين، مؤقت التأخير (Delay Timer) ومؤقت الصوت (Sound Timer). بينما تعمل وظيفة `tick` مرة واحدة في كل دورة لوحدة المعالجة المركزية، يتم تعديل هذه المؤقتات بدلاً من ذلك مرة واحدة في كل إطار، وبالتالي يجب التعامل معها في وظيفة منفصلة. سلوكها بسيط للغاية، ففي كل إطار ينخفض كل منهما بمقدار واحد. إذا تم تعيين مؤقت الصوت إلى واحد، فإن النظام سيصدر صوت "بيب". إذا وصلت المؤقتات إلى الصفر، فإنها لا تعيد تعيين نفسها تلقائيًا؛ بل تبقى عند الصفر حتى تقوم اللعبة بإعادة تعيينها يدويًا إلى بعض القيم.

```rust
pub fn tick_timers(&mut self) {
    if self.dt > 0 {
        self.dt -= 1;
    }

    if self.st > 0 {
        if self.st == 1 {
            // BEEP
        }
        self.st -= 1;
    }
}
```

الصوت هو الشيء الوحيد الذي لن يغطيه هذا الدليل، وذلك بسبب التعقيد المتزايد في جعل الصوت يعمل في كل من واجهاتنا الأمامية لسطح المكتب ومتصفح الويب. في الوقت الحالي سنترك ببساطة تعليقًا حيث سيحدث الصوت، ولكن أي قراء فضوليين مدعوون لتنفيذ ذلك بأنفسهم (ثم إخباري كيف فعلوا ذلك).

\newpage
