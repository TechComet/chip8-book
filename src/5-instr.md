# تنفيذ الأوامر (Opcode Execution)

في القسم السابق، قمنا بجلب الـ opcode وكنا نستعد لفك تشفير التعليمات التي يتوافق معها لتنفيذ تلك التعليمات. حاليًا، تبدو وظيفة `tick` كما يلي:

```rust
pub fn tick(&mut self) {
    // الجلب
    let op = self.fetch();
    // فك التشفير
    // التنفيذ
}
```

هذا يعني أن فك التشفير والتنفيذ سيكونان وظيفتين منفصلتين. بينما يمكن أن يكونا كذلك، بالنسبة لـ Chip-8، من الأسهل ببساطة تنفيذ العملية أثناء تحديدها، بدلاً من تضمين استدعاء وظيفة أخرى. وبالتالي تصبح وظيفة `tick` كما يلي:

```rust
pub fn tick(&mut self) {
    // الجلب
    let op = self.fetch();
    // فك التشفير والتنفيذ
    self.execute(op);
}

fn execute(&mut self, op: u16) {
    // TODO
}
```

خطوتنا التالية هي *فك التشفير*، أو تحديد بالضبط أي عملية نتعامل معها. تحتوي [ورقة الغش الخاصة بأوامر Chip-8](#ot) على جميع الأوامر المتاحة، وكيفية تفسير معاملاتها، وبعض الملاحظات حول معناها. ستحتاج إلى الرجوع إليها كثيرًا. بالنسبة لمحاكي كامل، يجب تنفيذ كل واحدة منها.

## مطابقة الأنماط (Pattern Matching)

لحسن الحظ، تمتلك Rust ميزة مطابقة الأنماط القوية والمفيدة التي يمكننا استخدامها لصالحنا. ومع ذلك، سنحتاج إلى فصل كل "رقم" سداسي عشري قبل القيام بذلك.

```rust
fn execute(&mut self, op: u16) {
    let digit1 = (op & 0xF000) >> 12;
    let digit2 = (op & 0x0F00) >> 8;
    let digit3 = (op & 0x00F0) >> 4;
    let digit4 = op & 0x000F;
}
```

ربما ليس هذا الكود الأكثر نظافة، ولكننا نحتاج إلى كل رقم سداسي عشري بشكل منفصل. من هنا، يمكننا إنشاء عبارة `match` حيث يمكننا تحديد الأنماط لجميع أوامرنا:

```rust
fn execute(&mut self, op: u16) {
    let digit1 = (op & 0xF000) >> 12;
    let digit2 = (op & 0x0F00) >> 8;
    let digit3 = (op & 0x00F0) >> 4;
    let digit4 = op & 0x000F;

    match (digit1, digit2, digit3, digit4) {
        (_, _, _, _) => unimplemented!("Unimplemented opcode: {}", op),
    }
}
```

تتطلب عبارة `match` في Rust أن يتم أخذ جميع الخيارات الممكنة في الاعتبار، وهو ما يتم باستخدام المتغير `_`، الذي يلتقط "كل شيء آخر". في الداخل، سنستخدم الماكرو `unimplemented!` للتسبب في ذعر البرنامج إذا وصل إلى هذه النقطة. بحلول الوقت الذي ننتهي فيه من إضافة جميع الأوامر، يطالب مترجم Rust بأن يكون لدينا عبارة "كل شيء آخر"، ولكننا لا ينبغي أن نصل إليها أبدًا.

بينما يمكن أن تعمل عبارة `match` الطويلة بالتأكيد مع بنى أخرى، فمن الشائع أكثر تنفيذ التعليمات في وظائفها الخاصة، واستخدام جدول بحث أو تحديد الوظيفة الصحيحة برمجيًا. Chip-8 غير عادية بعض الشيء لأنها تخزن معلمات التعليمات في الـ opcode نفسه، مما يعني أننا نحتاج إلى الكثير من الرموز البديلة لمطابقة التعليمات. نظرًا لوجود عدد صغير نسبيًا منها، تعمل عبارة `match` بشكل جيد هنا.

مع إعداد الإطار، دعنا نبدأ!

## مقدمة لتنفيذ الأوامر

تناقش الصفحات التالية كيفية عمل جميع تعليمات Chip-8، وتتضمن كودًا لكيفية تنفيذها. أنت مرحب ببساطة باتباعها وتنفيذ التعليمات واحدة تلو الأخرى، ولكن قبل أن تفعل ذلك، قد ترغب في النظر إلى [القسم التالي](#dfe) والبدء في العمل على بعض كود الواجهة الأمامية. حاليًا، ليس لدينا طريقة لتشغيل المحاكي فعليًا، وقد يكون من المفيد لبعض الأشخاص محاولة تحميل وتشغيل لعبة لأغراض التصحيح. ومع ذلك، تذكر أن المحاكي من المحتمل أن يتعطل بسرعة كبيرة ما لم يتم تنفيذ جميع التعليمات. شخصيًا، أفضل العمل على التعليمات أولاً قبل العمل على الأجزاء المتحركة الأخرى (ولهذا تم وضع هذا الدليل بهذه الطريقة).

مع هذا التحذير، دعنا ننتقل إلى العمل على كل تعليمات Chip-8 بالترتيب.

### 0000 - Nop

أول تعليمة لدينا هي الأبسط - لا تفعل شيئًا. قد يبدو هذا سخيفًا، ولكن في بعض الأحيان يكون ضروريًا لأغراض التوقيت أو المحاذاة. على أي حال، نحتاج ببساطة إلى الانتقال إلى الـ opcode التالي (الذي تم بالفعل في `fetch`)، والعودة.

```rust
match (digit1, digit2, digit3, digit4) {
    // NOP
    (0, 0, 0, 0) => return,
    (_, _, _, _) => unimplemented!("Unimplemented opcode: {}", op),
}
```

### 00E0 - مسح الشاشة

الـ opcode 0x00E0 هو التعليمات لمسح الشاشة، مما يعني أننا بحاجة إلى إعادة تعيين مخزن الشاشة ليكون فارغًا مرة أخرى.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // CLS
    (0, 0, 0xE, 0) => {
        self.screen = [false; SCREEN_WIDTH * SCREEN_HEIGHT];
    },

    // -- كود غير متغير محذوف --
}
```

### 00EE - العودة من الروتين الفرعي

لم نتحدث بعد عن الروتينات الفرعية (المعروفة أيضًا باسم الوظائف) وكيف تعمل. الدخول إلى روتين فرعي يعمل بنفس طريقة القفز العادي؛ ننقل عداد البرنامج (PC) إلى العنوان المحدد ونستأنف التنفيذ من هناك. على عكس القفز، من المتوقع أن يكمل الروتين الفرعي في مرحلة ما، وسنحتاج إلى العودة إلى النقطة التي دخلنا منها. هذا هو المكان الذي يأتي فيه المكدس. عندما ندخل إلى روتين فرعي، ندفع ببساطة عنواننا إلى المكدس، ونشغل كود الروتين، وعندما نكون مستعدين للعودة، نخرج هذه القيمة من المكدس وننفذ من تلك النقطة مرة أخرى. يسمح لنا المكدس أيضًا بالحفاظ على عناوين العودة للروتينات الفرعية المتداخلة مع ضمان إعادتها بالترتيب الصحيح.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // RET
    (0, 0, 0xE, 0xE) => {
        let ret_addr = self.pop();
        self.pc = ret_addr;
    },

    // -- كود غير متغير محذوف --
}
```

### 1NNN - القفز

تعليمة القفز سهلة الإضافة، ببساطة انقل عداد البرنامج (PC) إلى العنوان المحدد.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // JMP NNN
    (1, _, _, _) => {
        let nnn = op & 0xFFF;
        self.pc = nnn;
    },

    // -- كود غير متغير محذوف --
}
```

الشيء الرئيسي الذي يجب ملاحظته هنا هو أن هذا الـ opcode يتم تعريفه بـ '0x1' كأكثر رقم معنوي. الأرقام الأخرى تستخدم كمعاملات لهذه العملية، ومن هنا جاء الرمز `_` في عبارة المطابقة، هنا نريد أي شيء يبدأ بـ 1، ولكن ينتهي بأي ثلاثة أرقام للدخول إلى هذه العبارة.

### 2NNN - استدعاء روتين فرعي

عكس عملية "العودة من الروتين الفرعي"، سنقوم بإضافة عداد البرنامج الحالي إلى المكدس، ثم القفز إلى العنوان المحدد. إذا قفزت مباشرة إلى هنا، أوصي بقراءة قسم *العودة* للحصول على سياق إضافي.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // CALL NNN
    (2, _, _, _) => {
        let nnn = op & 0xFFF;
        self.push(self.pc);
        self.pc = nnn;
    },

    // -- كود غير متغير محذوف --
}
```

### 3XNN - تخطي التالي إذا كان VX == NN

هذا الـ opcode هو الأول من بين عدد قليل يتبع نمطًا مشابهًا. بالنسبة لأولئك الذين ليسوا على دراية بلغة التجميع، فإن القدرة على تخطي سطر تعطي وظيفة مشابهة لكتلة if-else. يمكننا إجراء مقارنة، وإذا كانت النتيجة صحيحة نذهب إلى تعليمة واحدة، وإذا كانت خاطئة نذهب إلى مكان آخر. هذا أيضًا هو أول opcode يستخدم أحد *سجلات V*. في هذه الحالة، يخبرنا الرقم الثاني أي سجل نستخدمه، بينما يوفر الرقمان الأخيران القيمة الخام.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // SKIP VX == NN
    (3, _, _, _) => {
        let x = digit2 as usize;
        let nn = (op & 0xFF) as u8;
        if self.v_reg[x] == nn {
            self.pc += 2;
        }
    },

    // -- كود غير متغير محذوف --
}
```

يعمل التنفيذ على النحو التالي: نظرًا لأننا لدينا بالفعل الرقم الثاني محفوظ في متغير، سنعيد استخدامه لفهرس 'X' الخاص بنا، على الرغم من تحويله إلى `usize`، حيث تتطلب Rust أن يتم فهرسة المصفوفات باستخدام متغير `usize`. إذا كانت القيمة المخزنة في هذا السجل تساوي `nn`، فإننا نتخطى الـ opcode التالي، وهو نفس تخطي عداد البرنامج (PC) بمقدار بايتين.

### 4XNN - تخطي التالي إذا كان VX != NN

هذا الـ opcode هو بالضبط نفس السابق، إلا أننا نتخطى إذا كانت القيم المقارنة غير متساوية.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // SKIP VX != NN
    (4, _, _, _) => {
        let x = digit2 as usize;
        let nn = (op & 0xFF) as u8;
        if self.v_reg[x] != nn {
            self.pc += 2;
        }
    },

    // -- كود غير متغير محذوف --
}
```

### 5XY0 - تخطي التالي إذا كان VX == VY

عملية مشابهة مرة أخرى، ولكننا الآن نستخدم الرقم الثالث للفهرسة في سجل *V* آخر. ستلاحظ أيضًا أن الرقم الأقل أهمية لا يستخدم في العملية. يتطلب هذا الـ opcode أن يكون 0.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // SKIP VX == VY
    (5, _, _, 0) => {
        let x = digit2 as usize;
        let y = digit3 as usize;
        if self.v_reg[x] == self.v_reg[y] {
            self.pc += 2;
        }
    },

    // -- كود غير متغير محذوف --
}
```

### 6XNN - VX = NN

قم بتعيين سجل *V* المحدد بواسطة الرقم الثاني إلى القيمة المعطاة.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // VX = NN
    (6, _, _, _) => {
        let x = digit2 as usize;
        let nn = (op & 0xFF) as u8;
        self.v_reg[x] = nn;
    },

    // -- كود غير متغير محذوف --
}
```

### 7XNN - VX += NN

تقوم هذه العملية بإضافة القيمة المعطاة إلى سجل VX. في حالة التدفق الزائد، سيتسبب Rust في ذعر، لذا نحتاج إلى استخدام طريقة مختلفة عن عامل الجمع المعتاد. لاحظ أيضًا أنه بينما يحتوي Chip-8 على علامة حمل (المزيد عن ذلك لاحقًا)، إلا أنها لا يتم تعديلها بواسطة هذه العملية.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // VX += NN
    (7, _, _, _) => {
        let x = digit2 as usize;
        let nn = (op & 0xFF) as u8;
        self.v_reg[x] = self.v_reg[x].wrapping_add(nn);
    },

    // -- كود غير متغير محذوف --
}
```

### 8XY0 - VX = VY

مثل عملية `VX = NN`، ولكن القيمة المصدر هي من سجل VY.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // VX = VY
    (8, _, _, 0) => {
        let x = digit2 as usize;
        let y = digit3 as usize;
        self.v_reg[x] = self.v_reg[y];
    },

    // -- كود غير متغير محذوف --
}
```

### 8XY1, 8XY2, 8XY3 - العمليات البتية

أكواد `8XY1`، `8XY2`، و `8XY3` هي جميعها وظائف متشابهة، لذا بدلاً من تكرار نفسي ثلاث مرات، سأقوم بتنفيذ عملية *OR*، وأسمح للقارئ بتنفيذ العمليتين الأخريين.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // VX |= VY
    (8, _, _, 1) => {
        let x = digit2 as usize;
        let y = digit3 as usize;
        self.v_reg[x] |= self.v_reg[y];
    },

    // -- كود غير متغير محذوف --
}
```

### 8XY4 - VX += VY

هذه العملية لها جانبين يجب ملاحظتهما. أولاً، هذه العملية لديها القدرة على التدفق الزائد، مما سيسبب ذعرًا في Rust إذا لم يتم التعامل معها بشكل صحيح. ثانيًا، هذه العملية هي الأولى التي تستخدم سجل `VF` كعلامة. لقد ذكرت ذلك سابقًا، ولكن بينما تكون أول 15 سجلًا من *V* للاستخدام العام، فإن السجل السادس عشر (0xF) يعمل أيضًا كـ *سجل العلامات*. سجلات العلامات شائعة في العديد من معالجات وحدة المعالجة المركزية؛ في حالة Chip-8، فإنه يخزن أيضًا *علامة الحمل*، وهي بشكل أساسي متغير خاص يلاحظ إذا كانت آخر عملية تطبيق أدت إلى تدفق زائد/تدفق تحت. هنا، إذا حدث تدفق زائد، نحتاج إلى تعيين `VF` ليكون 1، أو 0 إذا لم يحدث. مع أخذ هذين الجانبين في الاعتبار، سنستخدم سمة `overflowing_add` في Rust، والتي ستعيد مجموعة من كل من المجموع الملتف، بالإضافة إلى قيمة منطقية تشير إلى ما إذا كان قد حدث تدفق زائد.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // VX += VY
    (8, _, _, 4) => {
        let x = digit2 as usize;
        let y = digit3 as usize;

        let (new_vx, carry) = self.v_reg[x].overflowing_add(self.v_reg[y]);
        let new_vf = if carry { 1 } else { 0 };

        self.v_reg[x] = new_vx;
        self.v_reg[0xF] = new_vf;
    },

    // -- كود غير متغير محذوف --
}
```
### 8XY5 - VX -= VY

هذه العملية مشابهة للعملية السابقة، ولكن مع الطرح بدلاً من الجمع. الفرق الرئيسي هو أن علم الحمل `VF` يعمل بشكل معاكس. في عملية الجمع، يتم تعيين العلم إلى 1 إذا حدث تجاوز، أما هنا في حالة الطرح، إذا حدث نقص، يتم تعيين العلم إلى 0، والعكس صحيح. سنستخدم هنا الدالة `overflowing_sub`.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // VX -= VY
    (8, _, _, 5) => {
        let x = digit2 as usize;
        let y = digit3 as usize;

        let (new_vx, borrow) = self.v_reg[x].overflowing_sub(self.v_reg[y]);
        let new_vf = if borrow { 0 } else { 1 };

        self.v_reg[x] = new_vx;
        self.v_reg[0xF] = new_vf;
    },

    // -- كود غير متغير محذوف --
}
```

### 8XY6 - VX >>= 1

تقوم هذه العملية بإزاحة واحدة إلى اليمين للقيمة في VX، مع تخزين البت الذي تم إسقاطه في السجل `VF`. لسوء الحظ، لا يوجد عامل تشغيل مدمج في Rust لالتقاط البت المسقط، لذا سنقوم بذلك يدويًا.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // VX >>= 1
    (8, _, _, 6) => {
        let x = digit2 as usize;
        let lsb = self.v_reg[x] & 1;
        self.v_reg[x] >>= 1;
        self.v_reg[0xF] = lsb;
    },

    // -- كود غير متغير محذوف --
}
```

### 8XY7 - VX = VY - VX

تعمل هذه العملية بنفس طريقة العملية السابقة VX -= VY، ولكن مع تبديل المعاملات.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // VX = VY - VX
    (8, _, _, 7) => {
        let x = digit2 as usize;
        let y = digit3 as usize;

        let (new_vx, borrow) = self.v_reg[y].overflowing_sub(self.v_reg[x]);
        let new_vf = if borrow { 0 } else { 1 };

        self.v_reg[x] = new_vx;
        self.v_reg[0xF] = new_vf;
    },

    // -- كود غير متغير محذوف --
}
```

### 8XYE - VX <<= 1

تشبه عملية الإزاحة إلى اليمين، ولكننا نخزن القيمة التي تم تجاوزها في سجل العلم.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // VX <<= 1
    (8, _, _, 0xE) => {
        let x = digit2 as usize;
        let msb = (self.v_reg[x] >> 7) & 1;
        self.v_reg[x] <<= 1;
        self.v_reg[0xF] = msb;
    },

    // -- كود غير متغير محذوف --
}
```

### 9XY0 - تخطي إذا VX != VY

بعد الانتهاء من عمليات 0x8000، حان الوقت لإضافة عملية كانت مفقودة، وهي تخطي السطر التالي إذا كانت VX لا تساوي VY. هذا الكود مشابه لعملية 5XY0، ولكن مع عدم المساواة.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // تخطي إذا VX != VY
    (9, _, _, 0) => {
        let x = digit2 as usize;
        let y = digit3 as usize;
        if self.v_reg[x] != self.v_reg[y] {
            self.pc += 2;
        }
    },

    // -- كود غير متغير محذوف --
}
```

### ANNN - I = NNN

هذه هي العملية الأولى التي تستخدم *سجل I*، والذي سيتم استخدامه في عدة عمليات إضافية، بشكل أساسي كمؤشر عنوان إلى الذاكرة العشوائية. في هذه الحالة، نقوم ببساطة بتعيينه إلى القيمة 0xNNN المشفرة في هذه العملية.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // I = NNN
    (0xA, _, _, _) => {
        let nnn = op & 0xFFF;
        self.i_reg = nnn;
    },

    // -- كود غير متغير محذوف --
}
```

### BNNN - القفز إلى V0 + NNN

بينما استخدمت العمليات السابقة *سجل V* المحدد في العملية، فإن هذه العملية تستخدم دائمًا *سجل V0*. تقوم هذه العملية بنقل PC إلى مجموع القيمة المخزنة في *V0* والقيمة الخام 0xNNN المقدمة في العملية.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // القفز إلى V0 + NNN
    (0xB, _, _, _) => {
        let nnn = op & 0xFFF;
        self.pc = (self.v_reg[0] as u16) + nnn;
    },

    // -- كود غير متغير محذوف --
}
```

### CXNN - VX = rand() & NN

أخيرًا، شيء لكسر الرتابة! هذه العملية هي عملية توليد الأرقام العشوائية في Chip-8، مع لمسة خاصة، حيث يتم بعد ذلك تطبيق عملية AND على الرقم العشوائي مع أقل 8 بتات من العملية. بينما أصدر فريق Rust مكتبة لتوليد الأرقام العشوائية، إلا أنها ليست جزءًا من المكتبة القياسية، لذا سنضيفها إلى مشروعنا.

في `chip8_core/Cargo.toml`، أضف السطر التالي في مكان ما تحت `[dependencies]`:

```toml
rand = "^0.7.3"
```

ملاحظة: إذا كنت تخطط لاتباع هذا الدليل حتى النهاية، ستكون هناك تغييرات مستقبلية حول كيفية تضمين هذه المكتبة لدعم متصفح الويب. ومع ذلك، في هذه المرحلة من المشروع، يكفي تحديدها كما هي.

حان الوقت الآن لإضافة دعم توليد الأرقام العشوائية وتنفيذ هذه العملية. في أعلى `lib.rs`، سنحتاج إلى استيراد دالة من مكتبة `rand`:

```rust
use rand::random;
```

سنستخدم بعد ذلك الدالة `random` عند تنفيذ العملية:

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // VX = rand() & NN
    (0xC, _, _, _) => {
        let x = digit2 as usize;
        let nn = (op & 0xFF) as u8;
        let rng: u8 = random();
        self.v_reg[x] = rng & nn;
    },

    // -- كود غير متغير محذوف --
}
```

لاحظ أن تحديد `rng` كمتغير من النوع `u8` ضروري حتى تعرف الدالة `random()` النوع الذي يجب أن تولده.

### DXYN - رسم Sprite

هذه العملية هي على الأرجح الأكثر تعقيدًا، لذا اسمح لي أن أشرح بالتفصيل كيفية عملها. بدلاً من رسم وحدات البكسل الفردية أو المستطيلات على الشاشة في كل مرة، تعرض شاشة Chip-8 *sprites*، وهي صور مخزنة في الذاكرة يتم نسخها إلى الشاشة في إحداثيات محددة (x, y). بالنسبة لهذه العملية، يعطينا الرقمان الثاني والثالث *سجلات V* التي سنستخدمها لجلب إحداثيات (x, y). حتى الآن، الأمور جيدة. Sprites في Chip-8 تكون دائمًا بعرض 8 وحدات بكسل، ولكن يمكن أن يكون ارتفاعها متغيرًا من 1 إلى 16. يتم تحديد ذلك في الرقم الأخير من العملية. ذكرت سابقًا أن *سجل I* يستخدم بشكل متكرر لتخزين عنوان في الذاكرة، وهذا هو الحال هنا؛ يتم تخزين sprites الخاصة بنا صفًا تلو الآخر *بدءًا* من العنوان المخزن في *I*. لذا إذا طُلب منا رسم sprite بارتفاع 3 وحدات بكسل، فإن بيانات الصف الأول مخزنة في \*I، يليها \*I + 1، ثم \*I + 2. هذا يفسر سبب كون جميع sprites بعرض 8 وحدات بكسل، حيث يتم تعيين بايت واحد لكل صف، وهو 8 بتات، واحد لكل بكسل، أسود أو أبيض. التفصيل الأخير الذي يجب ملاحظته هو أنه إذا تم تغيير أي بكسل من الأبيض إلى الأسود أو العكس، يتم تعيين *VF* (ويتم مسحه في حالة عدم التغيير). مع وضع هذه الأشياء في الاعتبار، دعنا نبدأ.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // رسم
    (0xD, _, _, _) => {
        // الحصول على إحداثيات (x, y) للـ sprite
        let x_coord = self.v_reg[digit2 as usize] as u16;
        let y_coord = self.v_reg[digit3 as usize] as u16;
        // الرقم الأخير يحدد عدد الصفوف التي يتكون منها الـ sprite
        let num_rows = digit4;

        // تتبع إذا تم تغيير أي وحدات بكسل
        let mut flipped = false;
        // التكرار على كل صف من الـ sprite
        for y_line in 0..num_rows {
            // تحديد عنوان الذاكرة الذي يتم فيه تخزين بيانات الصف
            let addr = self.i_reg + y_line as u16;
            let pixels = self.ram[addr as usize];
            // التكرار على كل عمود في الصف
            for x_line in 0..8 {
                // استخدام قناع لجلب بت البكسل الحالي. يتم التغيير فقط إذا كان البت 1
                if (pixels & (0b1000_0000 >> x_line)) != 0 {
                    // يجب أن تلتف الـ sprites حول الشاشة، لذا نطبق عملية modulo
                    let x = (x_coord + x_line) as usize % SCREEN_WIDTH;
                    let y = (y_coord + y_line) as usize % SCREEN_HEIGHT;

                    // الحصول على فهرس البكسل لمصفوفة الشاشة أحادية البعد
                    let idx = x + SCREEN_WIDTH * y;
                    // التحقق مما إذا كنا على وشك تغيير البكسل وتعيين
                    flipped |= self.screen[idx];
                    self.screen[idx] ^= true;
                }
            }
        }

        // تعيين سجل VF
        if flipped {
            self.v_reg[0xF] = 1;
        } else {
            self.v_reg[0xF] = 0;
        }
    },

    // -- كود غير متغير محذوف --
}
```

### EX9E - تخطي إذا تم الضغط على المفتاح

حان الوقت أخيرًا لإدخال إدخال المستخدم. عند إعداد كائن المحاكاة الخاص بنا، ذكرت أن هناك 16 مفتاحًا ممكنًا مرقمًا من 0 إلى 0xF. تتحقق هذه العملية مما إذا كان المفتاح المخزن في VX مضغوطًا، وإذا كان الأمر كذلك، تتخطى العملية التالية.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // تخطي إذا تم الضغط على المفتاح
    (0xE, _, 9, 0xE) => {
        let x = digit2 as usize;
        let vx = self.v_reg[x];
        let key = self.keys[vx as usize];
        if key {
            self.pc += 2;
        }
    },

    // -- كود غير متغير محذوف --
}
```

### EXA1 - تخطي إذا لم يتم الضغط على المفتاح

نفس العملية السابقة، ولكن هذه المرة يتم تخطي العملية التالية إذا لم يتم الضغط على المفتاح المحدد.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // تخطي إذا لم يتم الضغط على المفتاح
    (0xE, _, 0xA, 1) => {
        let x = digit2 as usize;
        let vx = self.v_reg[x];
        let key = self.keys[vx as usize];
        if !key {
            self.pc += 2;
        }
    },

    // -- كود غير متغير محذوف --
}
```

### FX07 - VX = DT

ذكرت استخدام *مؤقت التأخير* عندما كنا نقوم بإعداد بنية المحاكاة. هذا المؤقت ينقص كل إطار حتى يصل إلى الصفر. ومع ذلك، فإن هذه العملية تحدث تلقائيًا، سيكون من المفيد حقًا أن نتمكن من رؤية ما يوجد في *مؤقت التأخير* لأغراض توقيت اللعبة. تقوم هذه العملية بذلك، وتخزن القيمة الحالية في أحد *سجلات V* لاستخدامها.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // VX = DT
    (0xF, _, 0, 7) => {
        let x = digit2 as usize;
        self.v_reg[x] = self.dt;
    },

    // -- كود غير متغير محذوف --
}
```

### FX0A - انتظار الضغط على المفتاح

بينما كانت لدينا بالفعل عمليات للتحقق مما إذا كانت المفاتيح مضغوطة أو غير مضغوطة، فإن هذه العملية تفعل شيئًا مختلفًا تمامًا. على عكس تلك العمليات، التي تحقق من حالة المفتاح ثم تستمر، فإن هذه العملية *توقف التنفيذ*، مما يعني أن اللعبة بأكملها ستتوقف وتنتظر طالما كان ذلك ضروريًا حتى يضغط اللاعب على مفتاح. هذا يعني أنها تحتاج إلى التكرار بلا نهاية حتى يصبح شيء ما في مصفوفة `keys` صحيحًا. بمجرد العثور على مفتاح، يتم تخزينه في VX. إذا كان هناك أكثر من مفتاح مضغوط حاليًا، يتم أخذ المفتاح ذي الفهرس الأصغر.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // انتظار الضغط على المفتاح
    (0xF, _, 0, 0xA) => {
        let x = digit2 as usize;
        let mut pressed = false;
        for i in 0..self.keys.len() {
            if self.keys[i] {
                self.v_reg[x] = i as u8;
                pressed = true;
                break;
            }
        }

        if !pressed {
            // إعادة تنفيذ العملية
            self.pc -= 2;
        }
    },

    // -- كود غير متغير محذوف --
}
```

قد تنظر إلى هذا التنفيذ وتسأل "لماذا نقوم بإعادة تعيين العملية والمرور عبر تسلسل الجلب بأكمله مرة أخرى، بدلاً من القيام بذلك ببساطة في حلقة؟". ببساطة، بينما نريد أن توقف هذه العملية العمليات المستقبلية من التنفيذ، لا نريد أن توقف أي ضغطات مفاتيح جديدة من التسجيل. من خلال البقاء في حلقة، سنمنع تشغيل كود الضغط على المفتاح، مما يتسبب في عدم انتهاء هذه الحلقة أبدًا. ربما يكون هذا غير فعال، ولكنه أبسط بكثير من بعض أنواع الفحص غير المتزامن.

### FX15 - DT = VX

تعمل هذه العملية في الاتجاه المعاكس لعملية *مؤقت التأخير* السابقة. نحتاج إلى طريقة لإعادة تعيين *مؤقت التأخير* إلى قيمة، وتسمح لنا هذه العملية بنسخ قيمة من *سجل V* نختاره.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // DT = VX
    (0xF, _, 1, 5) => {
        let x = digit2 as usize;
        self.dt = self.v_reg[x];
    },

    // -- كود غير متغير محذوف --
}
```

### FX18 - ST = VX

تقريبًا نفس العملية السابقة، ولكن هذه المرة سنقوم بتخزين القيمة من VX في *مؤقت الصوت*.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // ST = VX
    (0xF, _, 1, 8) => {
        let x = digit2 as usize;
        self.st = self.v_reg[x];
    },

    // -- كود غير متغير محذوف --
}
```

### FX1E - I += VX

تعمل العملية ANNN على تعيين I إلى القيمة المشفرة 0xNNN، ولكن في بعض الأحيان يكون من المفيد أن نتمكن من زيادة القيمة ببساطة. تأخذ هذه العملية القيمة المخزنة في VX وتضيفها إلى *سجل I*. في حالة التجاوز، يجب أن يعود السجل إلى 0، وهو ما يمكن تحقيقه باستخدام الدالة `wrapping_add` في Rust.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // I += VX
    (0xF, _, 1, 0xE) => {
        let x = digit2 as usize;
        let vx = self.v_reg[x] as u16;
        self.i_reg = self.i_reg.wrapping_add(vx);
    },

    // -- كود غير متغير محذوف --
}
```

### FX29 - تعيين I إلى عنوان الخط

هذه عملية أخرى صعبة حيث قد لا يكون واضحًا كيفية المضي قدمًا في البداية. إذا كنت تتذكر، قمنا بتخزين مجموعة من بيانات الخط في بداية الذاكرة العشوائية (RAM) عند تهيئة المحاكي. تريد هذه العملية أن نأخذ من VX رقمًا لطباعته على الشاشة (من 0 إلى 0xF)، ونخزن عنوان الذاكرة العشوائية لهذا الـ sprite في *سجل I*. في الواقع، يمكننا تخزين هذه الـ sprites في أي مكان نريده، طالما أننا متسقون ونشير إليها بشكل صحيح هنا. ومع ذلك، قمنا بتخزينها في موقع مناسب جدًا، في بداية الذاكرة العشوائية. دعني أوضح لك ما أعنيه عن طريق طباعة بعض الـ sprites وعناوين الذاكرة العشوائية الخاصة بها.

| الحرف | عنوان الذاكرة العشوائية |
| ----- | ----------------------- |
| 0     | 0                       |
| 1     | 5                       |
| 2     | 10                      |
| 3     | 15                      |
| ...   | ...                     |
| E (14)| 70                      |
| F (15)| 75                      |

ستلاحظ أنه نظرًا لأن جميع الـ sprites الخاصة بالخط تأخذ خمسة بايتات لكل منها، فإن عنوان الذاكرة العشوائية الخاص بها هو ببساطة قيمتها مضروبة في 5. إذا قمنا بتخزين الخطوط في عنوان ذاكرة عشوائية مختلف، فلا يزال بإمكاننا اتباع هذه القاعدة، ولكن يجب علينا تطبيق إزاحة على مكان بدء الكتلة.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // I = FONT
    (0xF, _, 2, 9) => {
        let x = digit2 as usize;
        let c = self.v_reg[x] as u16;
        self.i_reg = c * 5;
    },

    // -- كود غير متغير محذوف --
}
```

### FX33 - I = BCD لـ VX

معظم عمليات Chip-8 واضحة إلى حد ما، ويمكن تنفيذها بسهولة بمجرد سماع وصف غامض. ومع ذلك، هناك بعض العمليات الصعبة، مثل الرسم على الشاشة وهذه العملية، التي تقوم بتخزين [الرقم العشري المشفر ثنائيًا (BCD)](https://en.wikipedia.org/wiki/Binary-coded_decimal) لرقم مخزن في VX في *سجل I*. أشجعك على القراءة عن BCD إذا كنت غير معتاد عليها، ولكن هنا شرح سريع: في هذا البرنامج التعليمي، استخدمنا النظام الست عشري (hexadecimal) كثيرًا، والذي يعمل عن طريق تحويل أرقامنا العشرية العادية إلى نظام الأساس 16، وهو ما تفهمه أجهزة الكمبيوتر بسهولة أكبر. على سبيل المثال، الرقم العشري 100 سيصبح 0x64. هذا جيد لأجهزة الكمبيوتر، ولكنه ليس سهل الوصول للبشر، وبالتأكيد ليس للجمهور العام الذي سيلعب ألعابك. الغرض الرئيسي من BCD هو تحويل الرقم الست عشري مرة أخرى إلى رقم عشري شبه عشري لطباعته للمستخدم، مثل النقاط أو النتائج العالية. لذا بينما قد يخزن Chip-8 الرقم 0x64 داخليًا، فإن جلب BCD الخاص به سيعطينا `0x1, 0x0, 0x0`، والتي يمكننا طباعتها على الشاشة كـ "100". ستلاحظ أننا انتقلنا من بايت واحد إلى ثلاثة بايتات لتخزين جميع الأرقام الثلاثة لرقمنا، ولهذا السبب سنقوم بتخزين BCD في الذاكرة العشوائية، بدءًا من العنوان الموجود حاليًا في *سجل I* والمضي قدمًا. نظرًا لأن VX تخزن أرقامًا من 8 بت، والتي تتراوح من 0 إلى 255، فسنحصل دائمًا على ثلاثة بايتات، حتى إذا كانت بعضها صفرًا.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // BCD
    (0xF, _, 3, 3) => {
        let x = digit2 as usize;
        let vx = self.v_reg[x] as f32;

        // جلب رقم المئات عن طريق القسمة على 100 وإزالة الكسور
        let hundreds = (vx / 100.0).floor() as u8;
        // جلب رقم العشرات عن طريق القسمة على 10، وإزالة رقم الآحاد والكسور
        let tens = ((vx / 10.0) % 10.0).floor() as u8;
        // جلب رقم الآحاد عن طريق إزالة المئات والعشرات
        let ones = (vx % 10.0) as u8;

        self.ram[self.i_reg as usize] = hundreds;
        self.ram[(self.i_reg + 1) as usize] = tens;
        self.ram[(self.i_reg + 2) as usize] = ones;
    },

    // -- كود غير متغير محذوف --
}
```

بالنسبة لهذا التنفيذ، قمت بتحويل قيمة VX أولاً إلى `float`، حتى أتمكن من استخدام عمليات القسمة والـ modulo للحصول على كل رقم عشري. هذا ليس أسرع تنفيذ ولا الأقصر. ومع ذلك، فهو أحد أسهل الطرق للفهم. أنا متأكد من أن هناك بعض القراء المطلعين على النظام الثنائي الذين يشعرون بالاشمئزاز من أنني فعلت ذلك بهذه الطريقة، ولكن هذا الحل ليس لهم. هذا الحل موجه للقراء الذين لم يسبق لهم رؤية BCD من قبل، حيث أن فقدان بعض السرعة من أجل فهم أفضل هو مقايضة جيدة. ومع ذلك، بمجرد تنفيذ هذا، أشجع الجميع على البحث عن خوارزميات BCD أكثر كفاءة لإضافة بعض التحسينات السهلة إلى الكود.

### FX55 - تخزين V0 - VX في I

نحن على وشك الانتهاء! تقوم هاتان العمليتان الأخيرتان بملء *سجلات V* من V0 إلى VX المحدد (بما في ذلك) بنفس النطاق من القيم من الذاكرة العشوائية، بدءًا من العنوان الموجود في *سجل I*. تقوم العملية الأولى بتخزين القيم في الذاكرة العشوائية، بينما تقوم العملية التالية بتحميلها في الاتجاه المعاكس.

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // تخزين V0 - VX
    (0xF, _, 5, 5) => {
        let x = digit2 as usize;
        let i = self.i_reg as usize;
        for idx in 0..=x {
            self.ram[i + idx] = self.v_reg[idx];
        }
    },

    // -- كود غير متغير محذوف --
}
```

### FX65 - تحميل I إلى V0 - VX

```rust
match (digit1, digit2, digit3, digit4) {
    // -- كود غير متغير محذوف --

    // تحميل V0 - VX
    (0xF, _, 6, 5) => {
        let x = digit2 as usize;
        let i = self.i_reg as usize;
        for idx in 0..=x {
            self.v_reg[idx] = self.ram[i + idx];
        }
    },

    // -- كود غير متغير محذوف --
}
```

### الأفكار النهائية

هذا كل شيء! مع هذا، أصبح لدينا الآن وحدة معالجة مركزية Chip-8 مكتملة التنفيذ. ربما لاحظت أن العديد من قيم الأوامر المشفرة (opcodes) لم يتم تغطيتها، خاصة في نطاقات 0x0000 و0xE000 و0xF000. هذا أمر طبيعي. هذه الأوامر المشفرة غير محددة في التصميم الأصلي، وبالتالي إذا حاولت أي لعبة استخدامها، فسيؤدي ذلك إلى حدوث خطأ في وقت التشغيل. إذا كنت لا تزال فضوليًا بعد الانتهاء من هذا المحاكي، فهناك عدد من امتدادات Chip-8 التي تملأ بعض هذه الفجوات لإضافة وظائف إضافية، ولكنها لن يتم تغطيتها في هذا الدليل.
\newpage
