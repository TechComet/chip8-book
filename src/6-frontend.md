# كتابة الواجهة الأمامية لسطح المكتب {#dfe}

في هذا القسم، سنقوم أخيرًا بتوصيل جميع القطع وجعل المحاكي الخاص بنا يقوم بتحميل وتشغيل لعبة. في هذه المرحلة، أصبحت نواة المحاكي قادرة على تحليل ومعالجة أوامر اللعبة، وتحديث الشاشة والذاكرة والسجلات حسب الحاجة. بعد ذلك، سنحتاج إلى إضافة بعض الوظائف العامة لتوفير بعض الوظائف للواجهة الأمامية، مثل تحميل لعبة، قبول إدخال المستخدم، ومشاركة مخزن الشاشة ليتم عرضه.

## تعريض النواة للواجهة الأمامية

لم ننتهي بعد من `chip8_core`. نحتاج إلى إضافة بعض الوظائف العامة إلى بنية `Emu` لإعطاء الوصول إلى بعض العناصر.

في `chip8_core/src/lib.rs`، أضف الطريقة التالية إلى بنية `Emu`:

```rust
impl Emu {
    // -- كود غير متغير محذوف --

    pub fn get_display(&self) -> &[bool] {
        &self.screen
    }

    // -- كود غير متغير محذوف --
}
```

هذا ببساطة يمرر مؤشرًا إلى مصفوفة مخزن الشاشة إلى الواجهة الأمامية، حيث يمكن استخدامها لعرض الشاشة.

بعد ذلك، سنحتاج إلى التعامل مع ضغطات المفاتيح. لدينا بالفعل مصفوفة `keys`، ولكنها لم تتم كتابتها أبدًا. ستقوم الواجهة الأمامية بالتعامل مع قراءة ضغطات المفاتيح، ولكننا سنحتاج إلى تعريض وظيفة تسمح لها بالتفاعل وتعيين العناصر في مصفوفة `keys`.

```rust
impl Emu {
    // -- كود غير متغير محذوف --

    pub fn keypress(&mut self, idx: usize, pressed: bool) {
        self.keys[idx] = pressed;
    }

    // -- كود غير متغير محذوف --
}
```

هذه الوظيفة بسيطة جدًا. تأخذ الفهرس الخاص بالمفتاح الذي تم الضغط عليه وتعيين القيمة. كان بإمكاننا تقسيم هذه الوظيفة إلى `press_key` و `release_key`، ولكن هذا بسيط بما يكفي بحيث يظل الهدف واضحًا. تذكر أن `idx` يجب أن يكون أقل من 16 وإلا ستفشل البرنامج. يمكنك إضافة هذا القيد هنا، ولكن بدلاً من ذلك سنتعامل معه في الواجهة الأمامية ونفترض أنه تم التحقق منه بشكل صحيح في الخلفية، بدلاً من التحقق منه مرتين.

أخيرًا، نحتاج إلى طريقة لتحميل كود اللعبة من ملف إلى ذاكرتنا حتى يمكن تنفيذه. سنتعمق في هذا أكثر عندما نبدأ في القراءة من ملف في الواجهة الأمامية، ولكن في الوقت الحالي نحتاج إلى أخذ قائمة من البايتات ونسخها إلى ذاكرتنا.

```rust
impl Emu {
    // -- كود غير متغير محذوف --

    pub fn load(&mut self, data: &[u8]) {
        let start = START_ADDR as usize;
        let end = (START_ADDR as usize) + data.len();
        self.ram[start..end].copy_from_slice(data);
    }

    // -- كود غير متغير محذوف --
}
```

تقوم هذه الوظيفة بنسخ جميع القيم من شريحة الإدخال `data` إلى الذاكرة بدءًا من 0x200. تذكر أن أول 512 بايت من الذاكرة لا تحتوي على بيانات اللعبة، وهي فارغة باستثناء بيانات الـ sprites التي نقوم بتخزينها هناك.

## إعداد الواجهة الأمامية

أخيرًا، لنقم بإعداد الواجهة الأمامية للمحاكي حتى نتمكن من اختبار الأشياء ونأمل أن نلعب بعض الألعاب! إنشاء واجهة مستخدم رسومية متقدمة هو خارج نطاق هذا الدليل، سنقوم ببساطة ببدء المحاكي واختيار اللعبة التي نريد لعبها عبر وسيطة سطر الأوامر. لنقم بإعداد ذلك الآن.

في `desktop/src/main.rs`، سنحتاج إلى قراءة وسيطات سطر الأوامر لتلقي مسار ملف لعبة ROM الخاص بنا. كان بإمكاننا إنشاء عدة أعلام لإعدادات إضافية، ولكننا سنبقيها بسيطة ونقول أننا سنطلب وسيطة واحدة بالضبط - مسار اللعبة. أي عدد آخر وسنخرج بخطأ.

```rust
use std::env;

fn main() {
    let args: Vec<_> = env::args().collect();
    if args.len() != 2 {
        println!("Usage: cargo run path/to/game");
        return;
    }
}
```

هذا يأخذ جميع معلمات سطر الأوامر الممررة إلى متجه، وإذا لم يكن هناك اثنان (اسم البرنامج دائمًا مخزن في `args[0]`)، فإننا نطبع الإدخال الصحيح ونخرج. المسار الذي أدخله المستخدم موجود الآن في `args[1]`. سنحتاج إلى التأكد من أن هذا الملف صالح بمجرد محاولة فتحه، ولكن أولاً، لدينا بعض الأشياء الأخرى لإعدادها.

## إنشاء نافذة

لمشروع المحاكاة هذا، سنستخدم مكتبة SDL لإنشاء نافذة اللعبة والرسم عليها. SDL هي مكتبة رسم ممتازة مع دعم جيد لضغطات المفاتيح والرسم. هناك كمية صغيرة من الكود التمهيدي التي سنحتاجها لإعدادها، ولكن بمجرد الانتهاء من ذلك يمكننا بدء المحاكاة.

أولاً، سنحتاج إلى تضمينها في مشروعنا. افتح `desktop/Cargo.toml` وأضف `sdl2` إلى التبعيات:

```toml
[dependencies]
chip8_core = { path = "../chip8_core" }
sdl2 = "^0.34.3
```

الآن في `desktop/src/main.rs`، يمكننا البدء في تجميع كل شيء معًا. سنحتاج إلى الوظائف العامة التي حددناها في نواتنا، لذا دعنا نخبر Rust أننا بحاجة إليها باستخدام `use chip8_core::*`.

```rust
use chip8_core::*;
use std::env;

fn main() {
    let args: Vec<_> = env::args().collect();
    if args.len() != 2 {
        println!("Usage: cargo run path/to/game");
        return;
    }
}
```

داخل `chip8_core`، قمنا بإنشاء ثوابت عامة لتخزين حجم الشاشة، والتي نقوم الآن باستيرادها. ومع ذلك، نافذة لعبة بحجم 64x32 صغيرة جدًا على شاشات اليوم، لذا دعنا نضاعف حجمها قليلاً. بعد تجربة بعض الأرقام، وجدت أن مقياس 15x يعمل بشكل جيد على شاشتي، ولكن يمكنك تعديل هذا إذا كنت تفضل شيئًا آخر.

```rust
const SCALE: u32 = 15;
const WINDOW_WIDTH: u32 = (SCREEN_WIDTH as u32) * SCALE;
const WINDOW_HEIGHT: u32 = (SCREEN_HEIGHT as u32) * SCALE;
```

تذكر أن `SCREEN_WIDTH` و `SCREEN_HEIGHT` كانتا ثوابت عامة حددناهما في الخلفية ويتم تضمينهما الآن في هذه الحزمة عبر عبارة `use chip8_core::*`. SDL يتطلب أن تكون أحجام الشاشة من النوع `u32` بدلاً من `usize` لذا سنقوم بتحويلها هنا.

حان الوقت لإنشاء نافذة SDL الخاصة بنا! الكود التالي ببساطة ينشئ سياق SDL جديد، ثم يقوم بإنشاء النافذة نفسها واللوحة التي سنرسم عليها.

```rust
fn main() {
    // -- كود غير متغير محذوف --

    // إعداد SDL
    let sdl_context = sdl2::init().unwrap();
    let video_subsystem = sdl_context.video().unwrap();
    let window = video_subsystem
        .window("Chip-8 Emulator", WINDOW_WIDTH, WINDOW_HEIGHT)
        .position_centered()
        .opengl()
        .build()
        .unwrap();

    let mut canvas = window.into_canvas().present_vsync().build().unwrap();
    canvas.clear();
    canvas.present();
}
```

سنقوم بتهيئة SDL ونطلب منها إنشاء نافذة جديدة بحجمنا المضاعف. سنقوم أيضًا بوضعها في منتصف شاشة المستخدم. بعد ذلك، سنحصل على كائن اللوحة الذي سنرسم عليه، مع تفعيل VSYNC. ثم نقوم بمسحها وعرضها للمستخدم.

إذا حاولت تشغيلها الآن (أعطها اسم ملف وهمي للاختبار، مثل `cargo run test`)، ستظهر نافذة لفترة وجيزة قبل أن تغلق. هذا لأن نافذة SDL يتم إنشاؤها لفترة وجيزة، ولكن بعد ذلك ينتهي البرنامج وتغلق النافذة. سنحتاج إلى إنشاء حلقة اللعبة الرئيسية حتى لا ينتهي البرنامج فورًا، وبينما نحن في ذلك، دعنا نضيف بعض التعامل مع الخروج من النافذة إذا حاولنا إغلاقها (وإلا سيتعين عليك إجبار البرنامج على الإغلاق من مدير المهام).

يستخدم SDL شيئًا يسمى *مضخة الأحداث* للتحقق من الأحداث في كل حلقة. عن طريق التحقق من هذا، يمكننا جعل أشياء مختلفة تحدث لأحداث معينة، مثل محاولة إغلاق النافذة أو الضغط على مفتاح. في الوقت الحالي، سنقوم فقط بجعل البرنامج يخرج من حلقة اللعبة الرئيسية إذا احتاج إلى إغلاق النافذة.

سنحتاج إلى إخبار Rust أننا نرغب في استخدام `Event` من SDL:

```rust
use sdl2::event::Event;
```

وتعديل دالة `main` لإضافة حلقة اللعبة الأساسية:

```rust
fn main() {
    // -- كود غير متغير محذوف --

    // إعداد SDL
    let sdl_context = sdl2::init().unwrap();
    let video_subsystem = sdl_context.video().unwrap();
    let window = video_subsystem
        .window("Chip-8 Emulator", WINDOW_WIDTH, WINDOW_HEIGHT)
        .position_centered()
        .opengl()
        .build()
        .unwrap();

    let mut canvas = window.into_canvas().present_vsync().build().unwrap();
    canvas.clear();
    canvas.present();

    let mut event_pump = sdl_context.event_pump().unwrap();

    'gameloop: loop {
        for evt in event_pump.poll_iter() {
            match evt {
                Event::Quit{..} => {
                    break 'gameloop;
                },
                _ => ()
            }
        }
    }
}
```

هذه الإضافة تقوم بإعداد حلقة اللعبة الرئيسية، والتي تتحقق مما إذا كانت أي أحداث قد تم تشغيلها. إذا تم اكتشاف حدث `Quit` (عن طريق محاولة إغلاق النافذة)، فإن البرنامج يخرج من الحلقة، مما يؤدي إلى إنهائه. إذا حاولت تشغيلها مرة أخرى عبر `cargo run test`، ستظهر نافذة سوداء جديدة بعنوان 'Chip-8 Emulator'. يجب أن تغلق النافذة بنجاح دون مشاكل.

إنها تعمل! بعد ذلك، سنقوم بتهيئة نواة المحاكي `chip8_core`، وفتح وتحميل ملف اللعبة.

## تحميل ملف

الواجهة الأمامية لدينا يمكنها الآن إنشاء نافذة محاكاة جديدة، لذا حان الوقت لبدء تشغيل الخلفية أيضًا. ستكون خطوتنا التالية هي قراءة ملف لعبة فعليًا، وتمرير بياناته إلى الخلفية ليتم تخزينها في الذاكرة وتنفيذها. أولاً، نحتاج إلى وجود كائن خلفي لتمرير الأشياء إليه. لا يزال في `frontend/src/main.rs`، لنقم بإنشاء كائن المحاكاة الخاص بنا. تم بالفعل تضمين كائن `Emu` مع جميع العناصر العامة من `chip8_core`، لذا يمكننا التهيئة بحرية.

```rust
fn main() {
    // -- كود غير متغير محذوف --

    let mut chip8 = Emu::new();

    'gameloop: loop {
        // -- كود غير متغير محذوف --
    }
}
```

إنشاء كائن `Emu` يجب أن يتم في مكان ما قبل حلقة اللعبة الرئيسية، حيث سيتم فيها رسم المحاكاة والتعامل مع ضغطات المفاتيح. تذكر أن مسار اللعبة يتم تمريره من قبل المستخدم، لذا سنحتاج أيضًا إلى التأكد من أن هذا الملف موجود بالفعل قبل محاولة قراءته. سنحتاج أولاً إلى `use` بعض العناصر من المكتبة القياسية في `main.rs` لفتح ملف.

```rust
use std::fs::File;
use std::io::Read;
```

هذا واضح جدًا. بعد ذلك، سنقوم بفتح الملف المعطى لنا كمعامل سطر أوامر، وقراءته في مخزن مؤقت، ثم تمرير تلك البيانات إلى خلفية المحاكي.

```rust
fn main() {
    // -- كود غير متغير محذوف --
    let mut chip8 = Emu::new();

    let mut rom = File::open(&args[1]).expect("Unable to open file");
    let mut buffer = Vec::new();

    rom.read_to_end(&mut buffer).unwrap();
    chip8.load(&buffer);
    // -- كود غير متغير محذوف --
}
```

هناك بعض الأشياء التي يجب ملاحظتها هنا. في حالة عدم تمكن Rust من فتح الملف من المسار الذي أعطانا إياه المستخدم (على الأرجح لأنه غير موجود)، فإن شرط `expect` سيفشل وسيخرج البرنامج مع هذه الرسالة. ثانيًا، كان بإمكاننا إعطاء مسار الملف إلى الخلفية وتحميل البيانات هناك، ولكن قراءة الملف هي سلوك أكثر ملاءمة للواجهة الأمامية وهو أفضل هنا. والأهم من ذلك، خطتنا النهائية هي جعل هذا المحاكي يعمل في متصفح الويب مع تغييرات قليلة أو معدومة في الخلفية. كيفية قراءة المتصفح لملف تختلف كثيرًا عن كيفية قراءة نظام الملفات الخاص بك، لذا سنسمح للواجهات الأمامية بالتعامل مع القراءة، وتمرير البيانات بمجرد حصولنا عليها.

## تشغيل المحاكي والرسم على الشاشة

تم تحميل اللعبة في الذاكرة وحلقتنا الرئيسية تعمل. الآن نحتاج إلى إخبار الخلفية ببدء معالجة تعليماتها، والرسم فعليًا على الشاشة. إذا كنت تتذكر، فإن المحاكي يعمل من خلال دورة ساعة كلما تم استدعاء دالة `tick`، لذا دعنا نضيف ذلك إلى حلقتنا.

```rust
fn main() {
    // -- كود غير متغير محذوف --

    'gameloop: loop {
        for event in event_pump.poll_iter() {
            // -- كود غير متغير محذوف --
        }

        chip8.tick();
    }
}
```

الآن في كل مرة تدور فيها الحلقة، سيتقدم المحاكي من خلال تعليمة أخرى. قد يبدو هذا سهلاً للغاية، ولكننا قمنا بإعداده بحيث تقوم `tick` بتحريك جميع أجزاء الخلفية، بما في ذلك تعديل مخزن الشاشة. دعنا نضيف دالة ستجلب بيانات الشاشة من الخلفية وتحديث نافذة SDL الخاصة بنا. أولاً، نحتاج إلى `use` بعض العناصر الإضافية من SDL:

```rust
use sdl2::pixels::Color;
use sdl2::rect::Rect;
use sdl2::render::Canvas;
use sdl2::video::Window;
```

بعد ذلك، الدالة، التي ستأخذ مرجعًا إلى كائن `Emu` الخاص بنا، بالإضافة إلى مرجع قابل للتعديل إلى لوحة SDL الخاصة بنا. يتطلب رسم الشاشة بضع خطوات. أولاً، نقوم بمسح اللوحة لمحو الإطار السابق. بعد ذلك، نكرر من خلال مخزن الشاشة، ونرسم مستطيلًا أبيض في أي وقت تكون القيمة المعطاة صحيحة. نظرًا لأن Chip-8 تدعم الأسود والأبيض فقط؛ إذا قمنا بمسح الشاشة باللون الأسود، فإننا نحتاج فقط إلى الاهتمام برسم المربعات البيضاء.

```rust
fn draw_screen(emu: &Emu, canvas: &mut Canvas<Window>) {
    // مسح اللوحة باللون الأسود
    canvas.set_draw_color(Color::RGB(0, 0, 0));
    canvas.clear();

    let screen_buf = emu.get_display();
    // الآن تعيين لون الرسم إلى الأبيض، والتكرار خلال كل نقطة لمعرفة ما إذا كان يجب رسمها
    canvas.set_draw_color(Color::RGB(255, 255, 255));
    for (i, pixel) in screen_buf.iter().enumerate() {
        if *pixel {
            // تحويل الفهرس من المصفوفة أحادية البعد إلى موضع ثنائي الأبعاد (x, y)
            let x = (i % SCREEN_WIDTH) as u32;
            let y = (i / SCREEN_WIDTH) as u32;

            // رسم مستطيل في الموضع (x, y)، مع تكبيره حسب قيمة `SCALE`
            let rect = Rect::new((x * SCALE) as i32, (y * SCALE) as i32, SCALE, SCALE);
            canvas.fill_rect(rect).unwrap();
        }
    }
    canvas.present();
}
```

لتلخيص هذه الوظيفة، نحصل على مصفوفة الشاشة أحادية البعد ونكرر خلالها. إذا وجدنا بكسلًا أبيض (قيمة `true`)، فإننا نحسب الموضع ثنائي الأبعاد (x, y) للشاشة ونرسم مستطيلًا هناك، مع تكبيره حسب عامل `SCALE`.

سنستدعي هذه الوظيفة في الحلقة الرئيسية، مباشرة بعد استدعاء `tick`.

```rust
fn main() {
    // -- الكود غير المتغير محذوف --

    'gameloop: loop {
        for event in event_pump.poll_iter() {
            // -- الكود غير المتغير محذوف --
        }

        chip8.tick();
        draw_screen(&chip8, &mut canvas);
    }
}
```

قد يتساءل بعضكم عن هذا. يجب تحديث الشاشة بمعدل 60 إطارًا في الثانية، أو 60 هرتز. بالتأكيد يجب أن تكون المحاكاة أسرع من ذلك؟ نعم، ولكن دعونا نضع هذا التفكير جانبًا الآن. سنبدأ بالتأكد من أن الأمر يعمل بشكل أساسي قبل أن نصلح التوقيتات.

إذا كان لديك لعبة Chip-8، يمكنك تجربة تشغيل المحاكي الخاص بك مع لعبة فعلية عبر:

```
$ cargo run path/to/game
```

إذا سار كل شيء بشكل جيد، يجب أن تظهر النافذة وتبدأ اللعبة في التقديم واللعب! يجب أن تشعر بالإنجاز لوصولك إلى هذا الحد مع محاكيك الخاص.

كما ذكرت سابقًا، يجب أن تكون سرعة `tick` للمحاكاة أسرع من معدل تحديث اللوحة. إذا شاهدت لعبتك تعمل، قد تشعر بأنها بطيئة بعض الشيء. حاليًا، ننفذ تعليمة واحدة، ثم نرسم على الشاشة، ثم نكرر. كما تعلمون، يتطلب الأمر عدة تعليمات لإجراء أي تغييرات ذات معنى على الشاشة. للتغلب على هذا، سنسمح للمحاكي بالتنفيذ عدة مرات قبل إعادة الرسم.

الآن، هذا هو المكان الذي تصبح فيه الأمور تجريبية بعض الشيء. مواصفات Chip-8 لا تقول أي شيء عن مدى سرعة النظام. حتى تركها كما هي الآن لتشغيلها بسرعة 60 هرتز هو حل صالح (وأنت مرحب بفعل ذلك). سنسمح ببساطة لوظيفة `tick` بالتكرار عدة مرات قبل الانتقال إلى رسم الشاشة. شخصيًا، أجد (وغيري من المحاكيات التي نظرت إليها) أن 10 تكرارات لكل إطار هو نقطة مثالية.

```rust
const TICKS_PER_FRAME: usize = 10;
// -- الكود غير المتغير محذوف --

fn main() {
    // -- الكود غير المتغير محذوف --

    'gameloop: loop {
        for event in event_pump.poll_iter() {
            // -- الكود غير المتغير محذوف --
        }

        for _ in 0..TICKS_PER_FRAME {
            chip8.tick();
        }
        draw_screen(&chip8, &mut canvas);
    }
}
```

قد يشعر بعضكم أن هذا غير دقيق بعض الشيء (وأنا أتفق معكم إلى حد ما). ومع ذلك، هذه أيضًا هي الطريقة التي تعمل بها الأنظمة الأكثر "تطورًا"، مع استثناء أن تلك المعالجات عادةً ما يكون لديها طريقة لإعلام الشاشة بأنها جاهزة لإعادة الرسم. نظرًا لأن Chip-8 لا تملك مثل هذه الآلية ولا أي سرعة ساعة محددة، فإن هذه طريقة أسهل لإنجاز هذه المهمة.

إذا قمت بالتشغيل مرة أخرى، قد تلاحظ أن الأمر لا يصل بعيدًا قبل التوقف. هذا على الأرجح بسبب أننا لم نقم بتحديث المؤقتين لدينا، لذا فإن المحاكي ليس لديه مفهوم عن مقدار الوقت الذي مر لألعابه. لقد ذكرت سابقًا أن المؤقتين يعملان مرة واحدة لكل إطار، بدلًا من سرعة الساعة، لذا يمكننا تعديل المؤقتين في نفس النقطة التي نعدل فيها الشاشة.

```rust
fn main() {
    // -- الكود غير المتغير محذوف --

    'gameloop: loop {
        for event in event_pump.poll_iter() {
            // -- الكود غير المتغير محذوف --
        }

        for _ in 0..TICKS_PER_FRAME {
            chip8.tick();
        }
        chip8.tick_timers();
        draw_screen(&chip8, &mut canvas);
    }
}
```

لا يزال هناك بعض الأشياء المتبقية للتنفيذ (على سبيل المثال، لا يمكنك التحكم في لعبتك) ولكنها بداية رائعة، ونحن في المراحل النهائية الآن!

## إضافة إدخال المستخدم

يمكننا أخيرًا تقديم لعبة Chip-8 إلى الشاشة، ولكننا لا نستطيع التقدم كثيرًا في اللعب لأننا لا نملك طريقة للتحكم بها. لحسن الحظ، يدعم SDL قراءة المدخلات من لوحة المفاتيح والتي يمكننا ترجمتها وإرسالها إلى محاكاتنا الخلفية.

كمراجعة، يدعم نظام Chip-8 16 مفتاحًا مختلفًا. هذه المفاتيح عادةً ما تكون منظمة في شبكة 4x4، مع المفاتيح من 0 إلى 9 مرتبة مثل الهاتف والمفاتيح من A إلى F محيطة بها. بينما يمكنك تنظيم المفاتيح بأي تكوين تريده، افترض بعض مطوري الألعاب أنها في نمط الشبكة عند اختيار مدخلات ألعابهم، مما يعني أنه يمكن أن يكون من الصعب لعب بعض الألعاب بطريقة أخرى. بالنسبة لمحاكاتنا، سنستخدم المفاتيح اليسرى من لوحة المفاتيح QWERTY كمدخلاتنا، كما هو موضح أدناه.

لنقم بإنشاء وظيفة لتحويل نوع المفتاح في SDL إلى القيم التي سنرسلها إلى المحاكي. سنحتاج إلى إدخال دعم لوحة المفاتيح في `main.rs` عبر:

```rust
use sdl2::keyboard::Keycode;
```

الآن، سننشئ وظيفة جديدة تأخذ `Keycode` وتخرج قيمة `u8` اختيارية. هناك فقط 16 مفتاحًا صالحًا، لذا سنلف قيمة الإخراج الصالحة في `Some`، ونعيد `None` إذا ضغط المستخدم على مفتاح غير Chip-8. هذه الوظيفة هي مجرد مطابقة لجميع المفاتيح الصالحة كما هو موضح في الصورة أعلاه.

```rust
fn key2btn(key: Keycode) -> Option<usize> {
    match key {
        Keycode::Num1 =>    Some(0x1),
        Keycode::Num2 =>    Some(0x2),
        Keycode::Num3 =>    Some(0x3),
        Keycode::Num4 =>    Some(0xC),
        Keycode::Q =>       Some(0x4),
        Keycode::W =>       Some(0x5),
        Keycode::E =>       Some(0x6),
        Keycode::R =>       Some(0xD),
        Keycode::A =>       Some(0x7),
        Keycode::S =>       Some(0x8),
        Keycode::D =>       Some(0x9),
        Keycode::F =>       Some(0xE),
        Keycode::Z =>       Some(0xA),
        Keycode::X =>       Some(0x0),
        Keycode::C =>       Some(0xB),
        Keycode::V =>       Some(0xF),
        _ =>                None,
    }
}
```

![تخطيط لوحة المفاتيح إلى مفاتيح Chip-8](img/input_layout.png)

بعد ذلك، سنضيف حدثين إضافيين إلى حلقة الأحداث الرئيسية، أحدهما لـ `KeyDown` والآخر لـ `KeyUp`. سيتم التحقق من كل حدث إذا كان المفتاح المضغوط يعطي قيمة `Some` من وظيفة `key2btn`، وإذا كان الأمر كذلك، يتم تمريرها إلى المحاكي عبر وظيفة `keypress` العامة التي قمنا بتعريفها سابقًا. الاختلاف الوحيد بين الاثنين هو ما إذا كان يتم تعيينها أو مسحها.

```rust
fn main() {
    // -- الكود غير المتغير محذوف --
    'gameloop: loop {
        for evt in event_pump.poll_iter() {
            match evt {
                Event::Quit{..} => {
                    break 'gameloop;
                },
                Event::KeyDown{keycode: Some(key), ..} => {
                    if let Some(k) = key2btn(key) {
                        chip8.keypress(k, true);
                    }
                },
                Event::KeyUp{keycode: Some(key), ..} => {
                    if let Some(k) = key2btn(key) {
                        chip8.keypress(k, false);
                    }
                },
                _ => ()
            }

        for _ in 0..TICKS_PER_FRAME {
            chip8.tick();
        }
        chip8.tick_timers();
        draw_screen(&chip8, &mut canvas);
    }
    // -- الكود غير المتغير محذوف --
}
```

عبارة `if let` تكون محققة فقط إذا كانت القيمة على اليمين تطابق تلك على اليسار، أي أن `key2btn(key)` تعيد قيمة `Some`. القيمة التي تم فكها يتم تخزينها بعد ذلك في `k`.

لنضيف أيضًا قدرة شائعة في المحاكيات - إغلاق البرنامج بالضغط على Escape. سنضيف ذلك بجانب حدث `Quit`.

```rust
fn main() {
    // -- الكود غير المتغير محذوف --
    'gameloop: loop {
        for evt in event_pump.poll_iter() {
            match evt {
                Event::Quit{..} | Event::KeyDown{keycode: Some(Keycode::Escape), ..}=> {
                    break 'gameloop;
                },
                Event::KeyDown{keycode: Some(key), ..} => {
                    if let Some(k) = key2btn(key) {
                        chip8.keypress(k, true);
                    }
                },
                Event::KeyUp{keycode: Some(key), ..} => {
                    if let Some(k) = key2btn(key) {
                        chip8.keypress(k, false);
                    }
                },
                _ => ()
            }
        }

        for _ in 0..TICKS_PER_FRAME {
            chip8.tick();
        }
        chip8.tick_timers();
        draw_screen(&chip8, &mut canvas);
    }
    // -- الكود غير المتغير محذوف --
}
```

على عكس أحداث المفاتيح الأخرى، حيث نتحقق من المتغير `key` الذي تم العثور عليه، نريد استخدام مفتاح Escape للإغلاق. إذا كنت لا تريد هذه القدرة في محاكاتك، أو تريد بعض الوظائف الأخرى للضغط على المفاتيح، فأنت مرحب بذلك.

هذا كل شيء! الواجهة الأمامية لمحاكي Chip-8 لدينا على سطح المكتب مكتملة الآن. يمكننا تحديد لعبة عبر معلمة سطر الأوامر، وتحميلها وتنفيذها، وعرض الإخراج على الشاشة، والتعامل مع إدخال المستخدم.

آمل أن تكون قد تمكنت من فهم كيفية عمل المحاكاة. نظام Chip-8 هو نظام بسيط إلى حد ما، ولكن التقنيات التي تمت مناقشتها هنا تشكل الأساس لكيفية عمل جميع المحاكيات.

ومع ذلك، هذا الدليل لم ينته بعد! في القسم التالي سأناقش كيفية بناء محاكاتنا باستخدام WebAssembly وجعله يعمل في متصفح الويب.

\newpage
